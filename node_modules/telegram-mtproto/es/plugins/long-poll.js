function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import Bluebird from 'bluebird';

import { tsNow } from '../service/time-manager';
import { NetworkerThread } from '../service/networker/index';

// import Logger from 'mtproto-logger'
// const log = Logger`long-poll`

// let inited = false

class LongPoll {

  constructor(thread) {
    this.maxWait = 25e3;
    this.pendingTime = Date.now();
    this.requestTime = Date.now();
    this.isActive = true;

    this.thread = thread;
    // if (inited) {
    //   log('Networker')(thread)
    //   //$ FlowIssue
    //   this.request = () => Bluebird.resolve()
    // }
    // inited = true
  }

  setPendingTime() {
    var now = tsNow();
    this.requestTime = now;
    this.pendingTime = now + this.maxWait;
  }
  request() {
    var _this = this;

    return _asyncToGenerator(function* () {
      var result = yield _this.thread.wrapMtpCall('http_wait', {
        max_delay: 1000,
        wait_after: 500,
        max_wait: _this.maxWait
      }, {
        noResponse: true,
        longPoll: true
      });
      _this.thread.checkLongPoll();
      return result;
    })();
  }

  writePollTime() {
    this.requestTime = tsNow();
  }

  allowLongPoll() {
    return this.requestTime + 3500 < tsNow();
  }

  sendLongPool() {
    //TODO add base dc check
    if (!this.isActive) return Bluebird.resolve(false);
    if (!this.allowLongPoll()) return Bluebird.resolve(false);
    this.setPendingTime();
    return this.request();
  }
}

export default LongPoll;
//# sourceMappingURL=long-poll.js.map